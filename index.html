<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Sarah Meister — UI/UX & 3D</title>

<style>
  :root{
    --bg0:#f7f9fc;
    --bg1:#eef3f8;

    --ink:#0b1320;

    --r: 26px;
    --padx: clamp(14px, 4vw, 60px);
    --max: 1120px;
  }

  * , *::before, *::after{ box-sizing:border-box; }
  html, body{ width:100%; max-width:100%; overflow-x:hidden; margin:0; }
  html{ scroll-behavior:smooth; }

  body{
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    color: var(--ink);
    background:
      radial-gradient(560px 380px at 18% 18%, rgba(124, 92, 255, .10), transparent 62%),
      radial-gradient(640px 420px at 82% 22%, rgba(0, 224, 255, .10), transparent 62%),
      radial-gradient(820px 560px at 70% 86%, rgba(255, 110, 199, .08), transparent 65%),
      radial-gradient(1200px 760px at 20% 0%, rgba(255,255,255,.92), transparent 62%),
      radial-gradient(1000px 700px at 85% 15%, rgba(255,255,255,.78), transparent 62%),
      linear-gradient(180deg, var(--bg0), var(--bg1));
  }

  /* subtle noise */
  .noise{
    position:fixed; inset:0; pointer-events:none; z-index:-1;
    background-image:
      url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='240' height='240'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='240' height='240' filter='url(%23n)' opacity='.20'/%3E%3C/svg%3E");
    opacity:.09;
    mix-blend-mode: overlay;
  }

  .container{
    width:min(var(--max), calc(100% - (var(--padx) * 2)));
    margin:0 auto;
  }

  /* ===== NAV (stable, no shifting) ===== */
  nav{
    position:sticky; top:0; z-index:40;
    padding: 14px var(--padx);
    display:grid;
    grid-template-columns: auto 1fr auto;
    align-items:center;
    gap:14px;

    background: rgba(247,249,252,.18);
    border-bottom: 1px solid rgba(255,255,255,.26);
    backdrop-filter: blur(14px) saturate(1.25);
    -webkit-backdrop-filter: blur(14px) saturate(1.25);
  }
  .brand{
    display:flex; align-items:baseline; gap:10px;
    font-weight:750; letter-spacing:.02em;
  }
  .brand small{
    font-weight:650;
    font-size:11px;
    letter-spacing:.18em;
    text-transform:uppercase;
    color: rgba(11,19,32,.50);
  }
  .nav-links{ display:flex; justify-content:center; gap:10px; align-items:center; }
  .nav-links a{
    text-decoration:none;
    color: rgba(11,19,32,.70);
    font-weight:600;
    font-size:14px;
    padding:10px 12px;
    border-radius:999px;
    transition: background .18s ease, transform .18s ease, color .18s ease;
  }
  .nav-links a:hover{ background: rgba(255,255,255,.32); color: var(--ink); transform: translateY(-1px); }

  .nav-btn{
    justify-self:end;
    display:inline-flex; align-items:center; justify-content:center;
    padding: 12px 16px;
    border-radius: 999px;
    text-decoration:none;
    font-weight: 650;
    color: rgba(11,19,32,.85);

    background: rgba(255,255,255,.14);
    border: 1px solid rgba(255,255,255,.60);
    border-bottom-color: rgba(11,19,32,.10);

    box-shadow:
      0 16px 38px rgba(10,18,35,.08),
      inset 0 1px 0 rgba(255,255,255,.75),
      inset 0 -12px 22px rgba(11,19,32,.05);

    backdrop-filter: blur(10px) saturate(1.15);
    -webkit-backdrop-filter: blur(10px) saturate(1.15);

    transition: transform .18s ease, background .18s ease;
  }
  .nav-btn:hover{ transform: translateY(-2px); background: rgba(255,255,255,.18); }

  /* ===== HERO with free-floating bubble area ===== */
  .hero{
    padding: clamp(64px, 9vh, 120px) 0 70px;
  }
  .hero-grid{
    display:grid;
    grid-template-columns: 1fr minmax(320px, 520px);
    gap: clamp(18px, 4vw, 42px);
    align-items:center;
  }
  @media (max-width: 980px){
    .hero-grid{ grid-template-columns: 1fr; }
  }

  .kicker{
    display:inline-block;
    letter-spacing:.18em;
    text-transform:uppercase;
    font-size:12px;
    color: rgba(11,19,32,.55);
    margin-bottom: 14px;
  }
  h1{
    margin:0 0 14px;
    font-family: ui-serif, Georgia, "Times New Roman", Times, serif;
    font-weight: 620;
    letter-spacing:-0.02em;
    line-height:1.02;
    font-size: clamp(38px, 5.6vw, 74px);
  }
  .sub{
    max-width: 70ch;
    margin:0 0 22px;
    color: rgba(11,19,32,.70);
    font-size: 16.5px;
    line-height: 1.7;
  }

  .actions{ display:flex; gap:12px; flex-wrap:wrap; }

  .btn{
    display:inline-flex; align-items:center; justify-content:center;
    padding: 12px 16px;
    border-radius: 999px;
    text-decoration:none;
    font-weight: 650;
    color: rgba(11,19,32,.85);

    background: rgba(255,255,255,.12);
    border: 1px solid rgba(255,255,255,.52);
    border-bottom-color: rgba(11,19,32,.10);

    box-shadow:
      0 16px 38px rgba(10,18,35,.08),
      inset 0 1px 0 rgba(255,255,255,.80),
      inset 0 -12px 22px rgba(11,19,32,.05);

    backdrop-filter: blur(10px) saturate(1.25);
    -webkit-backdrop-filter: blur(10px) saturate(1.25);

    transition: transform .18s ease, background .18s ease;
  }
  .btn:hover{ transform: translateY(-2px); background: rgba(255,255,255,.16); }

  .btn-primary{
    background: rgba(11,19,32,.92);
    color: rgba(255,255,255,.92);
    border-color: rgba(11,19,32,.18);
    box-shadow: 0 18px 42px rgba(11,19,32,.14);
    backdrop-filter:none;
    -webkit-backdrop-filter:none;
  }

  /* FREE bubble area: transparent, no card, no background */
  .bubble-area{
    position:relative;
    height: 420px;        /* stays in this area */
    overflow:hidden;      /* IMPORTANT: bubbles stay inside */
    user-select:none;
    touch-action:none;
  }
  @media (max-width: 980px){
    .bubble-area{ height: 360px; }
  }
  #bubbleCanvas{ width:100%; height:100%; display:block; }

  @media (prefers-reduced-motion: reduce){
    .btn, .nav-btn, .nav-links a{ transition:none !important; }
  }
</style>
</head>

<body>
  <div class="noise" aria-hidden="true"></div>

  <nav>
    <div class="brand">S.M. <small>Portfolio</small></div>
    <div class="nav-links">
      <a href="#projekte">Projekte</a>
      <a href="#leistungen">Leistungen</a>
      <a href="#ueber">Über mich</a>
    </div>
    <a class="nav-btn" href="#kontakt">Kontakt</a>
  </nav>

  <main class="container">
    <section class="hero" id="top">
      <div class="hero-grid">
        <div>
          <span class="kicker">Digitale Ökosysteme · Räume der Intuition & Interaktion</span>
          <h1>UI/UX Designerin<br>&amp; 3D Artist</h1>
          <p class="sub">
            Intelligente Interfaces, lichtgeführte Räume und kuratierte visuelle Systeme —
            strukturiert, elegant und lebendig.
          </p>
          <div class="actions">
            <a class="btn btn-primary" href="#projekte">Projekte ansehen →</a>
            <a class="btn" href="#leistungen">Leistungen</a>
          </div>
        </div>

        <!-- transparent, free-floating bubble cluster area -->
        <div class="bubble-area" aria-label="Interaktive Glasblasen">
          <canvas id="bubbleCanvas"></canvas>
        </div>
      </div>
    </section>
  </main>

<script>
(() => {
  const canvas = document.getElementById("bubbleCanvas");
  const ctx = canvas.getContext("2d", { alpha:true });

  // === sizing
  let dpr = 1;
  function resize(){
    const rect = canvas.getBoundingClientRect();
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  resize();
  window.addEventListener("resize", resize);

  const W = () => canvas.getBoundingClientRect().width;
  const H = () => canvas.getBoundingClientRect().height;

  // === pointer (interaction ONLY inside canvas)
  const pointer = { x:0, y:0, active:false, down:false };
  let dragged = null;

  function localXY(clientX, clientY){
    const r = canvas.getBoundingClientRect();
    return { x: clientX - r.left, y: clientY - r.top };
  }

  canvas.addEventListener("mousemove", (e)=>{
    const p = localXY(e.clientX, e.clientY);
    pointer.x = p.x; pointer.y = p.y;
  });
  canvas.addEventListener("mouseenter", ()=>{ pointer.active = true; });
  canvas.addEventListener("mouseleave", ()=>{
    pointer.active = false;
    pointer.down = false;
    dragged = null;
  });

  canvas.addEventListener("mousedown", (e)=>{
    const p = localXY(e.clientX, e.clientY);
    pointer.x = p.x; pointer.y = p.y;
    pointer.down = true;
    dragged = pickBubble(pointer.x, pointer.y);
  });
  window.addEventListener("mouseup", ()=>{
    pointer.down = false;
    dragged = null;
  });

  // Touch (optional)
  canvas.addEventListener("touchstart", (e)=>{
    const t = e.touches[0]; if(!t) return;
    const p = localXY(t.clientX, t.clientY);
    pointer.x = p.x; pointer.y = p.y;
    pointer.active = true;
    pointer.down = true;
    dragged = pickBubble(pointer.x, pointer.y);
  }, { passive:true });

  canvas.addEventListener("touchmove", (e)=>{
    const t = e.touches[0]; if(!t) return;
    const p = localXY(t.clientX, t.clientY);
    pointer.x = p.x; pointer.y = p.y;
  }, { passive:true });

  canvas.addEventListener("touchend", ()=>{
    pointer.down = false;
    dragged = null;
    pointer.active = false;
  }, { passive:true });

  // === cluster bubbles (STATIC until hover)
  const bubbles = [];

  // Feel (tuned for "still until hover")
  const SPRING = 0.020;      // return to rest
  const DAMP   = 0.965;      // damping
  const COLLIDE = 0.62;      // separation strength
  const PUSH_R = 170;        // hover radius
  const PUSH_S = 0.75;       // hover strength
  const DRAG_K = 0.35;       // drag follow

  function center(){ return { x: W()*0.52, y: H()*0.54 }; }

  function seed(){
    bubbles.length = 0;
    const c = center();

    // Pinterest-like cluster: 1 big + surrounding
    const sizes = [82, 56, 50, 46, 42, 38, 36];
    const rests = [
      {x: 0,   y: 18},
      {x:-92,  y:-22},
      {x: 92,  y:-16},
      {x:-78,  y: 86},
      {x: 84,  y: 100},
      {x: 0,   y:-98},
      {x: 138, y: 66}
    ];

    for(let i=0;i<sizes.length;i++){
      const r = sizes[i];
      const ro = rests[i];
      bubbles.push({
        r,
        // start exactly at rest => no initial motion
        x: c.x + ro.x,
        y: c.y + ro.y,
        rx: c.x + ro.x,
        ry: c.y + ro.y,
        vx: 0,
        vy: 0
      });
    }
  }
  seed();

  window.addEventListener("resize", ()=>{
    // re-center rests on resize
    const c = center();
    const base = { x: W()*0.52, y: H()*0.54 };
    for(const b of bubbles){
      const ox = b.rx - base.x;
      const oy = b.ry - base.y;
      b.rx = c.x + ox;
      b.ry = c.y + oy;
      // keep positions proportional
      b.x = b.rx; b.y = b.ry;
      b.vx = 0; b.vy = 0;
    }
  });

  function pickBubble(x,y){
    const sorted = [...bubbles].sort((a,b)=>b.r-a.r);
    for(const b of sorted){
      const dx = x - b.x, dy = y - b.y;
      if(dx*dx + dy*dy <= b.r*b.r) return b;
    }
    return null;
  }

  function clampInside(b){
    const w = W(), h = H();
    b.x = Math.max(b.r, Math.min(w - b.r, b.x));
    b.y = Math.max(b.r, Math.min(h - b.r, b.y));
  }

  function collide(a,b){
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const d = Math.hypot(dx,dy) || 0.0001;
    const min = a.r + b.r;

    if(d < min){
      const nx = dx / d;
      const ny = dy / d;
      const overlap = (min - d) * COLLIDE;

      a.x -= nx * overlap * 0.5;
      a.y -= ny * overlap * 0.5;
      b.x += nx * overlap * 0.5;
      b.y += ny * overlap * 0.5;

      // small impulse for jelly feel
      const iv = 0.12;
      a.vx -= nx * iv; a.vy -= ny * iv;
      b.vx += nx * iv; b.vy += ny * iv;
    }
  }

  // === metaball / "sticky connection" (draw bridges)
  function drawMetaball(a, b, maxDist){
    const d = Math.hypot(b.x - a.x, b.y - a.y);
    const r1 = a.r, r2 = b.r;
    const minDist = r1 + r2;

    // only connect when close (like "together")
    if(d > maxDist || d <= Math.abs(r1 - r2) || d <= 0.0001) return;

    const u1 = Math.acos((r1*r1 + d*d - r2*r2) / (2*r1*d));
    const u2 = Math.acos((r2*r2 + d*d - r1*r1) / (2*r2*d));
    const angleBetween = Math.atan2(b.y - a.y, b.x - a.x);

    // influence based on distance
    const t = Math.max(0, Math.min(1, (d - minDist) / (maxDist - minDist)));
    const v = 0.60 * (1 - t); // stronger when closer

    const angle1a = angleBetween + u1 + (Math.PI/2 - u1) * v;
    const angle1b = angleBetween - u1 - (Math.PI/2 - u1) * v;
    const angle2a = angleBetween + Math.PI - u2 - (Math.PI/2 - u2) * v;
    const angle2b = angleBetween + Math.PI + u2 + (Math.PI/2 - u2) * v;

    const p1a = { x: a.x + r1 * Math.cos(angle1a), y: a.y + r1 * Math.sin(angle1a) };
    const p1b = { x: a.x + r1 * Math.cos(angle1b), y: a.y + r1 * Math.sin(angle1b) };
    const p2a = { x: b.x + r2 * Math.cos(angle2a), y: b.y + r2 * Math.sin(angle2a) };
    const p2b = { x: b.x + r2 * Math.cos(angle2b), y: b.y + r2 * Math.sin(angle2b) };

    const handleLen = (Math.min(1, (d - minDist) / (maxDist - minDist))) * 0.9;
    const h1 = r1 * handleLen;
    const h2 = r2 * handleLen;

    const h1a = { x: p1a.x + h1 * Math.cos(angle1a - Math.PI/2), y: p1a.y + h1 * Math.sin(angle1a - Math.PI/2) };
    const h2a = { x: p2a.x + h2 * Math.cos(angle2a + Math.PI/2), y: p2a.y + h2 * Math.sin(angle2a + Math.PI/2) };
    const h1b = { x: p1b.x + h1 * Math.cos(angle1b + Math.PI/2), y: p1b.y + h1 * Math.sin(angle1b + Math.PI/2) };
    const h2b = { x: p2b.x + h2 * Math.cos(angle2b - Math.PI/2), y: p2b.y + h2 * Math.sin(angle2b - Math.PI/2) };

    // bridge fill (same glass feel)
    ctx.save();
    ctx.globalCompositeOperation = "source-over";

    const grad = ctx.createLinearGradient(a.x, a.y, b.x, b.y);
    grad.addColorStop(0, "rgba(255,255,255,0.12)");
    grad.addColorStop(0.5, "rgba(255,255,255,0.06)");
    grad.addColorStop(1, "rgba(255,255,255,0.12)");

    ctx.beginPath();
    ctx.moveTo(p1a.x, p1a.y);
    ctx.bezierCurveTo(h1a.x, h1a.y, h2a.x, h2a.y, p2a.x, p2a.y);
    ctx.lineTo(p2b.x, p2b.y);
    ctx.bezierCurveTo(h2b.x, h2b.y, h1b.x, h1b.y, p1b.x, p1b.y);
    ctx.closePath();
    ctx.fillStyle = grad;
    ctx.fill();

    // subtle rainbow rim for the bridge (Pinterest-ish)
    ctx.globalCompositeOperation = "screen";
    ctx.lineWidth = 1.2;
    const rim = ctx.createLinearGradient(p1a.x, p1a.y, p2a.x, p2a.y);
    rim.addColorStop(0, "rgba(255,80,180,0.12)");
    rim.addColorStop(0.5,"rgba(80,220,255,0.10)");
    rim.addColorStop(1, "rgba(255,220,80,0.08)");
    ctx.strokeStyle = rim;
    ctx.stroke();

    ctx.restore();
  }

  function drawBubble(b){
    const r = b.r;

    // glass fill
    const g1 = ctx.createRadialGradient(
      b.x - r*0.32, b.y - r*0.32, r*0.12,
      b.x, b.y, r
    );
    g1.addColorStop(0,  "rgba(255,255,255,0.94)");
    g1.addColorStop(0.24,"rgba(255,255,255,0.24)");
    g1.addColorStop(0.62,"rgba(255,255,255,0.09)");
    g1.addColorStop(1,  "rgba(255,255,255,0.04)");

    ctx.beginPath();
    ctx.arc(b.x, b.y, r, 0, Math.PI*2);
    ctx.fillStyle = g1;
    ctx.fill();

    // rainbow rim (very subtle, like chromatic aberration)
    ctx.save();
    ctx.globalCompositeOperation = "screen";
    ctx.lineWidth = Math.max(1.2, r*0.03);
    const arcs = [
      { col:"rgba(255,80,180,0.16)", ox:-0.8, oy:-0.5 },
      { col:"rgba(80,220,255,0.14)", ox: 0.8, oy:-0.2 },
      { col:"rgba(255,220,80,0.10)", ox: 0.0, oy: 0.8 }
    ];
    for(const a of arcs){
      ctx.strokeStyle = a.col;
      ctx.beginPath();
      ctx.arc(b.x + a.ox, b.y + a.oy, r*0.985, -0.25, Math.PI*1.50);
      ctx.stroke();
    }
    ctx.restore();

    // rim
    ctx.strokeStyle = "rgba(255,255,255,0.52)";
    ctx.lineWidth = 1.6;
    ctx.beginPath();
    ctx.arc(b.x, b.y, r, 0, Math.PI*2);
    ctx.stroke();

    // highlights
    ctx.save();
    ctx.globalCompositeOperation = "screen";
    ctx.beginPath();
    ctx.arc(b.x - r*0.30, b.y - r*0.30, r*0.28, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,0.14)";
    ctx.fill();

    ctx.beginPath();
    ctx.arc(b.x - r*0.18, b.y - r*0.40, r*0.12, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,0.20)";
    ctx.fill();
    ctx.restore();
  }

  function nearStill(){
    // if no interaction and tiny velocities -> hard stop (prevents “drifting”)
    if(pointer.active) return false;
    for(const b of bubbles){
      if(Math.abs(b.vx) > 0.02 || Math.abs(b.vy) > 0.02) return false;
    }
    return true;
  }

  function step(){
    const w = W(), h = H();
    ctx.clearRect(0,0,w,h);

    // Update only meaningfully on hover/drag OR while returning to rest
    for(const b of bubbles){
      // spring always pulls back, but at rest it stays still
      b.vx += (b.rx - b.x) * SPRING;
      b.vy += (b.ry - b.y) * SPRING;

      // hover push ONLY when pointer is inside the canvas
      if(pointer.active && !pointer.down){
        const dx = b.x - pointer.x;
        const dy = b.y - pointer.y;
        const d = Math.hypot(dx,dy) || 0.0001;
        if(d < PUSH_R){
          const f = (1 - d / PUSH_R) * PUSH_S;
          b.vx += (dx/d) * f;
          b.vy += (dy/d) * f;
        }
      }

      // drag
      if(pointer.down && dragged === b){
        b.vx += (pointer.x - b.x) * DRAG_K;
        b.vy += (pointer.y - b.y) * DRAG_K;
      }

      // integrate
      b.x += b.vx;
      b.y += b.vy;

      // damping
      b.vx *= DAMP;
      b.vy *= DAMP;

      clampInside(b);
    }

    // collisions (always)
    for(let i=0;i<bubbles.length;i++){
      for(let j=i+1;j<bubbles.length;j++){
        collide(bubbles[i], bubbles[j]);
      }
    }

    // sticky connections under bubbles
    const maxBridge = 230;
    for(let i=0;i<bubbles.length;i++){
      for(let j=i+1;j<bubbles.length;j++){
        drawMetaball(bubbles[i], bubbles[j], maxBridge);
      }
    }

    // draw bubbles top
    const sorted = [...bubbles].sort((a,b)=>a.r-b.r);
    for(const b of sorted) drawBubble(b);

    // lock to complete stillness when not hovering (Pinterest “static render” feel)
    if(nearStill()){
      for(const b of bubbles){ b.x = b.rx; b.y = b.ry; b.vx = 0; b.vy = 0; }
    }

    requestAnimationFrame(step);
  }

  step();
})();
</script>
</body>
</html>
