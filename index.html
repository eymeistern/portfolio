<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Sarah Meister — UI/UX & 3D</title>

<style>
  :root{
    --bg0:#f7f9fc;
    --bg1:#eef3f8;
    --ink:#0b1320;
    --ink2:rgba(11,19,32,.72);

    --r: 26px;
    --padx: clamp(14px, 4vw, 60px);
    --max: 1120px;

    --shadowA: 0 34px 120px rgba(10,18,35,.10);
    --shadowB: 0 14px 38px rgba(10,18,35,.07);

    /* slightly stronger background energy so glass pops */
    --c1: rgba(140,210,255,.26);
    --c2: rgba(205,175,255,.22);
    --c3: rgba(255,210,170,.18);
  }

  * , *::before, *::after{ box-sizing:border-box; }
  html, body{ width:100%; max-width:100%; overflow-x:hidden; margin:0; }
  html{ scroll-behavior:smooth; }
  body{
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    color: var(--ink);
    background:
      radial-gradient(560px 380px at 20% 18%, rgba(124, 92, 255, .14), transparent 62%),
      radial-gradient(640px 420px at 82% 22%, rgba(0, 224, 255, .12), transparent 62%),
      radial-gradient(820px 560px at 70% 86%, rgba(255, 110, 199, .10), transparent 65%),
      radial-gradient(1200px 760px at 20% 0%, rgba(255,255,255,.92), transparent 62%),
      radial-gradient(1000px 700px at 85% 15%, rgba(255,255,255,.78), transparent 62%),
      linear-gradient(180deg, var(--bg0), var(--bg1));
  }

  .atmo{
    position:fixed; inset:-20%; pointer-events:none; z-index:-2;
    background:
      radial-gradient(700px 420px at 18% 20%, var(--c1), transparent 70%),
      radial-gradient(720px 460px at 78% 22%, var(--c2), transparent 72%),
      radial-gradient(820px 540px at 55% 78%, var(--c3), transparent 72%);
    filter: blur(6px);
    opacity:.95;
  }

  .noise{
    position:fixed; inset:0; pointer-events:none; z-index:-1;
    background-image:
      url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='240' height='240'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='240' height='240' filter='url(%23n)' opacity='.20'/%3E%3C/svg%3E");
    opacity:.10;
    mix-blend-mode: overlay;
  }

  .container{
    width:min(var(--max), calc(100% - (var(--padx) * 2)));
    margin:0 auto;
  }

  /* ===== NAV (stable, no shifting) ===== */
  nav{
    position:sticky; top:0; z-index:40;
    padding: 14px var(--padx);
    display:grid;
    grid-template-columns: auto 1fr auto;
    align-items:center;
    gap:14px;

    background: rgba(247,249,252,.18);
    border-bottom: 1px solid rgba(255,255,255,.26);
    backdrop-filter: blur(14px) saturate(1.35);
    -webkit-backdrop-filter: blur(14px) saturate(1.35);
  }
  .brand{
    display:flex; align-items:baseline; gap:10px;
    font-weight:750; letter-spacing:.02em;
  }
  .brand small{
    font-weight:650;
    font-size:11px;
    letter-spacing:.18em;
    text-transform:uppercase;
    color: rgba(11,19,32,.50);
  }
  .nav-links{
    display:flex; justify-content:center; gap:10px; align-items:center;
  }
  .nav-links a{
    text-decoration:none;
    color: rgba(11,19,32,.70);
    font-weight:600;
    font-size:14px;
    padding:10px 12px;
    border-radius:999px;
    transition: background .18s ease, transform .18s ease, color .18s ease;
  }
  .nav-links a:hover{ background: rgba(255,255,255,.32); color: var(--ink); transform: translateY(-1px); }

  .nav-btn{
    justify-self:end;
    display:inline-flex; align-items:center; justify-content:center;
    padding: 12px 16px;
    border-radius: 999px;
    text-decoration:none;
    font-weight: 650;
    color: rgba(11,19,32,.85);

    background: rgba(255,255,255,.14);
    border: 1px solid rgba(255,255,255,.60);
    border-bottom-color: rgba(11,19,32,.10);

    box-shadow:
      0 16px 38px rgba(10,18,35,.08),
      inset 0 1px 0 rgba(255,255,255,.75),
      inset 0 -12px 22px rgba(11,19,32,.05);

    backdrop-filter: blur(10px) saturate(1.25);
    -webkit-backdrop-filter: blur(10px) saturate(1.25);

    transition: transform .18s ease, background .18s ease;
  }
  .nav-btn:hover{ transform: translateY(-2px); background: rgba(255,255,255,.18); }

  /* ===== HERO with right bubble area ===== */
  .hero{
    padding: clamp(64px, 9vh, 120px) 0 60px;
  }
  .hero-grid{
    display:grid;
    grid-template-columns: 1fr minmax(340px, 520px);
    gap: clamp(18px, 4vw, 40px);
    align-items:center;
  }
  @media (max-width: 980px){
    .hero-grid{ grid-template-columns: 1fr; }
  }

  .kicker{
    display:inline-block;
    letter-spacing:.18em;
    text-transform:uppercase;
    font-size:12px;
    color: rgba(11,19,32,.55);
    margin-bottom: 14px;
  }
  h1{
    margin:0 0 14px;
    font-family: ui-serif, Georgia, "Times New Roman", Times, serif;
    font-weight: 620;
    letter-spacing:-0.02em;
    line-height:1.02;
    font-size: clamp(38px, 5.6vw, 74px);
  }
  .sub{
    max-width: 70ch;
    margin:0 0 22px;
    color: rgba(11,19,32,.70);
    font-size: 16.5px;
    line-height: 1.7;
  }

  .actions{ display:flex; gap:12px; flex-wrap:wrap; }

  .btn{
    display:inline-flex; align-items:center; justify-content:center;
    padding: 12px 16px;
    border-radius: 999px;
    text-decoration:none;
    font-weight: 650;
    color: rgba(11,19,32,.85);

    background: rgba(255,255,255,.12);
    border: 1px solid rgba(255,255,255,.52);
    border-bottom-color: rgba(11,19,32,.10);

    box-shadow:
      0 16px 38px rgba(10,18,35,.08),
      inset 0 1px 0 rgba(255,255,255,.80),
      inset 0 -12px 22px rgba(11,19,32,.05);

    backdrop-filter: blur(10px) saturate(1.35);
    -webkit-backdrop-filter: blur(10px) saturate(1.35);

    transition: transform .18s ease, background .18s ease;
  }
  .btn:hover{ transform: translateY(-2px); background: rgba(255,255,255,.16); }
  .btn-primary{
    background: rgba(11,19,32,.92);
    color: rgba(255,255,255,.92);
    border-color: rgba(11,19,32,.18);
    box-shadow: 0 18px 42px rgba(11,19,32,.14);
    backdrop-filter:none;
    -webkit-backdrop-filter:none;
  }

  /* Bubble area (confined) */
  .bubble-panel{
    position:relative;
    height: 420px;
    border-radius: 32px;
    overflow:hidden; /* IMPORTANT: bubbles stay inside */
    user-select:none;
    touch-action:none;

    background:
      radial-gradient(900px 420px at 40% 20%, rgba(255,255,255,.55), transparent 62%),
      radial-gradient(700px 460px at 80% 70%, rgba(185,220,255,.24), transparent 68%),
      linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,0));

    border: 1px solid rgba(255,255,255,.35);
    box-shadow:
      0 30px 90px rgba(10,18,35,.10),
      inset 0 1px 0 rgba(255,255,255,.55);
  }
  @media (max-width: 980px){
    .bubble-panel{ height: 360px; }
  }

  #bubbleCanvas{ width:100%; height:100%; display:block; }

  @media (prefers-reduced-motion: reduce){
    .btn, .nav-btn{ transition:none !important; }
  }
</style>
</head>

<body>
  <div class="atmo" aria-hidden="true"></div>
  <div class="noise" aria-hidden="true"></div>

  <nav>
    <div class="brand">S.M. <small>Portfolio</small></div>
    <div class="nav-links">
      <a href="#projekte">Projekte</a>
      <a href="#leistungen">Leistungen</a>
      <a href="#ueber">Über mich</a>
    </div>
    <a class="nav-btn" href="#kontakt">Kontakt</a>
  </nav>

  <main class="container">
    <section class="hero" id="top">
      <div class="hero-grid">
        <div>
          <span class="kicker">Digitale Ökosysteme · Räume der Intuition & Interaktion</span>
          <h1>UI/UX Designerin<br>&amp; 3D Artist</h1>
          <p class="sub">
            Intelligente Interfaces, lichtgeführte Räume und kuratierte visuelle Systeme —
            strukturiert, elegant und lebendig.
          </p>
          <div class="actions">
            <a class="btn btn-primary" href="#projekte">Projekte ansehen →</a>
            <a class="btn" href="#leistungen">Leistungen</a>
          </div>
        </div>

        <!-- Bubble cluster area (right of hero text) -->
        <div class="bubble-panel" aria-label="Interaktive Glasblasen">
          <canvas id="bubbleCanvas"></canvas>
        </div>
      </div>
    </section>
  </main>

<script>
(() => {
  const canvas = document.getElementById("bubbleCanvas");
  const ctx = canvas.getContext("2d", { alpha:true });

  // ===== sizing (crisp but safe) =====
  let dpr = 1;
  function resize(){
    const rect = canvas.getBoundingClientRect();
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  resize();
  window.addEventListener("resize", resize);

  // ===== pointer =====
  const pointer = { x:0, y:0, down:false, active:false, id:-1 };
  let dragged = null;

  function getLocal(e){
    const r = canvas.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
  }

  canvas.addEventListener("mousemove", (e)=>{
    const p = getLocal(e);
    pointer.x = p.x; pointer.y = p.y;
    pointer.active = true;
  });
  canvas.addEventListener("mouseleave", ()=>{
    pointer.active = false;
    dragged = null;
    pointer.down = false;
  });
  canvas.addEventListener("mousedown", (e)=>{
    const p = getLocal(e);
    pointer.x = p.x; pointer.y = p.y;
    pointer.down = true;
    dragged = pickBubble(p.x, p.y);
  });
  window.addEventListener("mouseup", ()=>{
    pointer.down = false;
    dragged = null;
  });

  // Touch (optional)
  canvas.addEventListener("touchstart", (e)=>{
    const t = e.touches[0];
    if(!t) return;
    const r = canvas.getBoundingClientRect();
    pointer.x = t.clientX - r.left;
    pointer.y = t.clientY - r.top;
    pointer.active = true;
    pointer.down = true;
    dragged = pickBubble(pointer.x, pointer.y);
  }, { passive:true });

  canvas.addEventListener("touchmove", (e)=>{
    const t = e.touches[0];
    if(!t) return;
    const r = canvas.getBoundingClientRect();
    pointer.x = t.clientX - r.left;
    pointer.y = t.clientY - r.top;
  }, { passive:true });

  canvas.addEventListener("touchend", ()=>{
    pointer.down = false;
    dragged = null;
    pointer.active = false;
  }, { passive:true });

  // ===== bubble cluster physics =====
  const W = () => canvas.getBoundingClientRect().width;
  const H = () => canvas.getBoundingClientRect().height;

  const bubbles = [];
  const center = () => ({ x: W()*0.52, y: H()*0.52 });

  // Tunables (feel)
  const SPRING = 0.018;     // pull back to rest position
  const DAMP   = 0.985;     // velocity damping
  const COLLIDE = 0.55;     // collision separation strength
  const PUSH_R = 170;       // hover influence radius
  const PUSH_S = 0.55;      // hover strength

  function rand(min,max){ return min + Math.random()*(max-min); }

  function seedCluster(){
    bubbles.length = 0;
    const c = center();

    // Similar to Pinterest: 1 large + surrounding
    const sizes = [78, 54, 48, 44, 40, 36, 34];
    // Rest offsets (cluster layout)
    const rests = [
      {x: 0,   y: 10},   // large center
      {x:-88,  y:-30},
      {x: 88,  y:-20},
      {x:-72,  y: 78},
      {x: 78,  y: 92},
      {x: 0,   y:-92},
      {x: 132, y: 58}
    ];

    for(let i=0;i<sizes.length;i++){
      const r = sizes[i];
      const ro = rests[i] || { x: rand(-120,120), y: rand(-90,110) };
      bubbles.push({
        r,
        x: c.x + ro.x + rand(-6,6),
        y: c.y + ro.y + rand(-6,6),
        vx: rand(-0.4,0.4),
        vy: rand(-0.4,0.4),
        rx: c.x + ro.x,
        ry: c.y + ro.y,
        wob: Math.random()*Math.PI*2
      });
    }
  }

  seedCluster();
  window.addEventListener("resize", () => {
    // re-center rest positions on resize
    const c = center();
    for(const b of bubbles){
      const ox = b.rx - (W()*0.52);
      const oy = b.ry - (H()*0.52);
      b.rx = c.x + ox;
      b.ry = c.y + oy;
    }
  });

  function pickBubble(x,y){
    // pick top-most (largest first)
    const sorted = [...bubbles].sort((a,b)=>b.r-a.r);
    for(const b of sorted){
      const dx = x - b.x, dy = y - b.y;
      if(dx*dx + dy*dy <= b.r*b.r) return b;
    }
    return null;
  }

  function clampInside(b){
    // keep inside panel
    const w = W(), h = H();
    b.x = Math.max(b.r, Math.min(w - b.r, b.x));
    b.y = Math.max(b.r, Math.min(h - b.r, b.y));
  }

  function collide(a,b){
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const d = Math.hypot(dx,dy) || 0.0001;
    const min = a.r + b.r;

    if(d < min){
      const nx = dx / d;
      const ny = dy / d;
      const overlap = (min - d) * COLLIDE;

      a.x -= nx * overlap * 0.5;
      a.y -= ny * overlap * 0.5;
      b.x += nx * overlap * 0.5;
      b.y += ny * overlap * 0.5;

      // small impulse (jelly)
      const iv = 0.18;
      a.vx -= nx * iv; a.vy -= ny * iv;
      b.vx += nx * iv; b.vy += ny * iv;
    }
  }

  // ===== rendering (VisionOS-ish) =====
  function drawBubble(b){
    const r = b.r * (1 + Math.sin(b.wob)*0.008);

    // Base glass fill
    const g1 = ctx.createRadialGradient(
      b.x - r*0.35, b.y - r*0.35, r*0.10,
      b.x, b.y, r
    );
    g1.addColorStop(0,  "rgba(255,255,255,0.92)");
    g1.addColorStop(0.22,"rgba(255,255,255,0.26)");
    g1.addColorStop(0.60,"rgba(255,255,255,0.10)");
    g1.addColorStop(1,  "rgba(255,255,255,0.04)");

    ctx.beginPath();
    ctx.arc(b.x, b.y, r, 0, Math.PI*2);
    ctx.fillStyle = g1;
    ctx.fill();

    // Inner soft shadow for thickness
    ctx.save();
    ctx.globalCompositeOperation = "multiply";
    const g2 = ctx.createRadialGradient(b.x, b.y, r*0.20, b.x, b.y, r);
    g2.addColorStop(0, "rgba(0,0,0,0)");
    g2.addColorStop(1, "rgba(10,18,35,0.08)");
    ctx.beginPath();
    ctx.arc(b.x, b.y, r, 0, Math.PI*2);
    ctx.fillStyle = g2;
    ctx.fill();
    ctx.restore();

    // Rainbow “refraction ring”
    ctx.save();
    ctx.globalCompositeOperation = "screen";
    ctx.lineWidth = Math.max(1.4, r*0.04);
    // draw 3 colored arcs slightly offset to mimic chromatic aberration
    const arcs = [
      { col:"rgba(255,80,180,0.20)", ox:-0.8, oy:-0.4 },
      { col:"rgba(80,220,255,0.18)", ox: 0.8, oy:-0.2 },
      { col:"rgba(255,220,80,0.14)", ox: 0.0, oy: 0.8 }
    ];
    for(const a of arcs){
      ctx.strokeStyle = a.col;
      ctx.beginPath();
      ctx.arc(b.x + a.ox, b.y + a.oy, r*0.98, -0.2, Math.PI*1.45);
      ctx.stroke();
    }
    ctx.restore();

    // Rim
    ctx.strokeStyle = "rgba(255,255,255,0.55)";
    ctx.lineWidth = 1.6;
    ctx.beginPath();
    ctx.arc(b.x, b.y, r, 0, Math.PI*2);
    ctx.stroke();

    // Specular highlights (2-layer)
    ctx.save();
    ctx.globalCompositeOperation = "screen";
    ctx.beginPath();
    ctx.arc(b.x - r*0.30, b.y - r*0.30, r*0.28, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,0.16)";
    ctx.fill();

    ctx.beginPath();
    ctx.arc(b.x - r*0.18, b.y - r*0.38, r*0.12, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,0.22)";
    ctx.fill();
    ctx.restore();
  }

  function step(){
    const w = W(), h = H();
    ctx.clearRect(0,0,w,h);

    // Update rest center drift (tiny ambient motion like the reference)
    const c = center();

    for(const b of bubbles){
      b.wob += 0.02;

      // spring back to rest position (cluster)
      const ax = (b.rx - b.x) * SPRING;
      const ay = (b.ry - b.y) * SPRING;

      b.vx += ax;
      b.vy += ay;

      // hover push
      if(pointer.active && !pointer.down){
        const dx = b.x - pointer.x;
        const dy = b.y - pointer.y;
        const d = Math.hypot(dx,dy) || 0.0001;
        if(d < PUSH_R){
          const f = (1 - d / PUSH_R) * PUSH_S;
          b.vx += (dx/d) * f;
          b.vy += (dy/d) * f;
        }
      }

      // drag (pull a bubble directly, others react by collisions)
      if(pointer.down && dragged === b){
        const k = 0.35; // follow strength
        b.vx += (pointer.x - b.x) * k;
        b.vy += (pointer.y - b.y) * k;
      }

      // integrate
      b.x += b.vx;
      b.y += b.vy;

      // damping
      b.vx *= DAMP;
      b.vy *= DAMP;

      // keep inside
      clampInside(b);
    }

    // Collisions
    for(let i=0;i<bubbles.length;i++){
      for(let j=i+1;j<bubbles.length;j++){
        collide(bubbles[i], bubbles[j]);
      }
    }

    // draw (big first looks more “3D stack”)
    const sorted = [...bubbles].sort((a,b)=>a.r-b.r);
    for(const b of sorted) drawBubble(b);

    requestAnimationFrame(step);
  }

  step();
})();
</script>

</body>
</html>
